import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.neighbors import NearestNeighbors


class ReliefF:
    def __init__(self, n_neighbors=5):
        self.n_neighbors = n_neighbors

    def fit(self, X, y):
        n_samples, n_features = X.shape
        self.weights = np.zeros(n_features)

        # Find k nearest neighbors for each sample
        knn = NearestNeighbors(n_neighbors=self.n_neighbors + 1)
        knn.fit(X)
        distances, indices = knn.kneighbors(X)

        for i in range(n_samples):
            near_hits = []  # 存储同类样本的索引
            near_misses = {}  # 存储不同类样本的索引，按类别分组

            # 遍历每个样本的 k 个近邻
            for j in range(1, self.n_neighbors + 1):
                if y[indices[i, j]] == y[i]:  # 同类样本
                    near_hits.append(indices[i, j])
                else:  # 不同类样本
                    if y[indices[i, j]] not in near_misses:
                        near_misses[y[indices[i, j]]] = []
                    near_misses[y[indices[i, j]]].append(indices[i, j])

            # 计算每个特征的权重
            for feature in range(n_features):
                # 计算同类样本的特征差异
                diff_hit = np.sum(np.abs(X[i, feature] - X[near_hits, feature])) / len(near_hits) if near_hits else 0
                # 计算不同类样本的特征差异
                diff_miss = 0
                for cls in near_misses:
                    diff_miss += np.sum(np.abs(X[i, feature] - X[near_misses[cls], feature])) / len(near_misses[cls])
                diff_miss /= len(near_misses) if near_misses else 1

                # 更新特征权重
                self.weights[feature] += (diff_miss - diff_hit) / (self.n_neighbors * n_samples)

        return self

    def get_weights(self):
        return self.weights


# 示例用法
if __name__ == "__main__":
    # 定义文件路径
    file_paths = [
        'data/train_opensmile_emodb.csv',
        'data/train-casia.csv',
        'data/train-ravdess.csv',
        'data/SAVEEdataset.csv'
    ]

    # 定义子图名称
    titles = ['emodb', 'casia', 'ravdess', 'savee']

    # 创建一个大图
    fig, axes = plt.subplots(2, 2, figsize=(15, 15))
    axes = axes.ravel()

    for idx, file_path in enumerate(file_paths):
        # 从 CSV 文件加载数据
        data = pd.read_csv(file_path)

        # 分离目标类别和特征
        y = data.iloc[:, 0].values  # 第一列是目标类别
        X = data.iloc[:, 1:].values  # 其余列是特征

        # 应用 ReliefF 算法
        relieff = ReliefF(n_neighbors=5)
        relieff.fit(X, y)

        # 获取特征权重
        weights = relieff.get_weights()

        # 定义权重区间
        bins = [0, 1, 2, 3, 4, 5, 6, np.inf]
        labels = ['0-1', '1-2', '2-3', '3-4', '4-5', '5-6', '6+']

        # 统计每个区间的特征数量
        weight_distribution = pd.cut(weights, bins=bins, labels=labels, right=False)
        weight_counts = weight_distribution.value_counts().sort_index()

        # 绘制饼状图
        explode = [i * 0.1 for i in range(len(weight_counts))]  # 每个部分逐次增加偏移距离

        # 绘制饼状图（去掉百分比）
        wedges, texts = axes[idx].pie(
            weight_counts,
            labels=labels,
            startangle=140,
            colors=plt.cm.Paired.colors,
            explode=explode,
            textprops={'fontsize': 10}  # 调整字体大小
        )

        # 添加图例
        axes[idx].legend(wedges, labels, title="Weight Ranges", loc="center left", bbox_to_anchor=(1, 0, 0.5, 1))

        # 设置标题为对应的名称
        axes[idx].set_title(f'Distribution of Feature Weights - {titles[idx]}', fontsize=8)

    plt.tight_layout()  # 调整布局
    plt.show()
